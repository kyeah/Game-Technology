Alyssa Sallean, Kevin Yeh, Patrick Grayson

Game Layout:
	- Game will be like wall ball/arcade racquetball
	- Scoring rules: consecutive hits will be one point; missing the wall will reset the score to 0.
	- GUI control: mouse clicks (right and left) for swinging right and left and wasd for movement around the court. It will look like the room from assignment one, with the walls looking like a raquetball court (pics from gregory?). There will be a dude with a flat racket (the dude himself may not be an actual dude). 
	- Whooshing sound for ball moving, bonk sound for ball collisions
	- Start with basic physics, and speed up the ball as your points increase (ie, making it harder as you go) 
	- Special spaces give you more points when you hit them

Software Architecture Plan:
	The software architecture will be similar to that in assignment 1.  We will use the sample BaseApplication.h and .cpp files along with necessary Bullet helper files.  The bulk of the application itself will be contained in a single .cpp file.  The game loop will be part of the simulation loop.  Our object structure will also be similar to assignment 1, with a single ball bouncing around a room composed of planes. 
	The only addition will be a user-controlled, racquet-wielding character.  Bullet will be used to check for collisions between the ball and any part of the user character or racquet. SDL will be used as a sound system.

Division of Labor:
	- Kevin Yeh: Bullet collision detection between ball, racket and walls
   	- Alyssa Sallean:  look, texturing, sound effects, keyboard input
	- Patrick Grayson: heads-up-display and scoring system

Design Clarifications:
       - The camera can either be a static shot encompassing the entirety of the world, or an over-the-shoulder camera angle.
       - Our implementation of the bullet physics engine and SDL sound engine will be abstracted away into a Simulator class and a base GameObject class. This GameObject class will be extended as necessary to provide unique properties for different shapes/meshes, textures, weights, restitutions, and sound effects. We may have a separate class for game logic, such as updating scores and reacting to user inputs. Our main class will delegate tasks to other classes, e.g. calling the game and simulation loops. The game loop will rely on collision detection and respond with appropriate actions.
